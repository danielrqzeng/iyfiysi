// gen by iyfiysi at {{ .CreateTime.Format "2006 Jan 02" }}

package {{.PackageName}}

import (
    "flag"
	"github.com/spf13/viper"
	"net/http"
    "strings"
	"fmt"
	"os"
    "github.com/grpc-ecosystem/grpc-gateway/runtime"

    "{{.Domain}}/{{.AppName}}/internal/pkg/logger"
    "{{.Domain}}/{{.AppName}}/internal/pkg/interceptor"
    "{{.Domain}}/{{.AppName}}/internal/pkg/utils"
    "{{.Domain}}/{{.AppName}}/internal/app/gateway/discovery"
    "{{.Domain}}/{{.AppName}}/internal/pkg/conf"
    "{{.Domain}}/{{.AppName}}/internal/pkg/governance"
)


//定义一个全局变量的命令行接收参数
var (
    etcdServerFlag  = flag.String("etcd", "http://127.0.0.1:2379", `etcd server,split with "," if more than one etcd server`)
	confKeyFlag     = flag.String("conf_key", "/{{.AppName}}/config/app.yaml", `etcd conf key`)
	confFlag        = flag.String("conf", "./conf/app.yaml", "configuration file")
	versionFlag     = flag.Bool("version", false, "print the current version")
)

// Variables set at build time
var (
	version = "v1.0.0"
	commit  = "unknown"
	date    = "unknown"
)



func initAll() {
	conf.Init()
	err := conf.InitRemoteConfig(
		strings.Split(*etcdServerFlag, ","),
		*confKeyFlag,
		func() {
			fmt.Println(viper.GetString("version"))
		})
	if err != nil {
		panic(err)
	}
	//做各个部件的初始化
	logger.Init()
	utils.Init()
}

func main() {
	flag.Parse()

	if *versionFlag {
		fmt.Printf("Version %v, commit %v, built at %v\n", version, commit, date)
		os.Exit(0)
	}

	initAll()

	etcdServers := viper.GetStringSlice("etcd.etcdServer")
	instanceIP := governance.GetGatewayInstanceAddr()
    instancePort := 0
    for i := viper.GetInt("server.minPort"); i < viper.GetInt("server.maxPort"); i++ {
    	if utils.IsPortAvailable(i) {
    		instancePort = i
    		break
    	}
    }
    instance := fmt.Sprintf("%s:%d", instanceIP, instancePort)
	jaegerServers := viper.GetStringSlice("jaeger.jaegerServer")

	grpcMux := runtime.NewServeMux()
	discovery.Discovery(grpcMux,etcdServers,jaegerServers[0])
	httpMux := http.NewServeMux()
	mux :=&interceptor.HttpInterceptor{grpcMux}
	httpMux.Handle("/", mux)

	// Start HTTP server (and proxy calls to gRPC server endpoint)
	http.ListenAndServe(instance, httpMux)
	return
}